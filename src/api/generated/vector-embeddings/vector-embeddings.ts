/**
 * Generated by orval v8.0.3 üç∫
 * Do not edit manually.
 * FastAPI Backend Project
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  SyncAllRequest,
  SyncAllResponse,
  UnifiedSearchRequest,
  UnifiedSearchResponse,
  VectorEmbeddingsSearchSimilarPrs200,
  VectorEmbeddingsSearchSimilarPrsParams,
  VectorEmbeddingsSyncAuthorVectors200,
  VectorEmbeddingsSyncAuthorVectorsParams
} from '../../model';

import { customFetch } from '../../../lib/custom-fetch';


type SecondParameter<T extends (...args: never) => unknown> = Parameters<T>[1];



/**
 * Sync PR vectors for a specific author.
 * @summary Sync Author Vectors
 */
export type vectorEmbeddingsSyncAuthorVectorsResponse200 = {
  data: VectorEmbeddingsSyncAuthorVectors200
  status: 200
}

export type vectorEmbeddingsSyncAuthorVectorsResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type vectorEmbeddingsSyncAuthorVectorsResponseSuccess = (vectorEmbeddingsSyncAuthorVectorsResponse200) & {
  headers: Headers;
};
export type vectorEmbeddingsSyncAuthorVectorsResponseError = (vectorEmbeddingsSyncAuthorVectorsResponse422) & {
  headers: Headers;
};

export type vectorEmbeddingsSyncAuthorVectorsResponse = (vectorEmbeddingsSyncAuthorVectorsResponseSuccess | vectorEmbeddingsSyncAuthorVectorsResponseError)

export const getVectorEmbeddingsSyncAuthorVectorsUrl = (params: VectorEmbeddingsSyncAuthorVectorsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vectors/sync/author?${stringifiedParams}` : `/api/v1/vectors/sync/author`
}

export const vectorEmbeddingsSyncAuthorVectors = async (params: VectorEmbeddingsSyncAuthorVectorsParams, options?: RequestInit): Promise<vectorEmbeddingsSyncAuthorVectorsResponse> => {
  
  return customFetch<vectorEmbeddingsSyncAuthorVectorsResponse>(getVectorEmbeddingsSyncAuthorVectorsUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getVectorEmbeddingsSyncAuthorVectorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>, TError,{params: VectorEmbeddingsSyncAuthorVectorsParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>, TError,{params: VectorEmbeddingsSyncAuthorVectorsParams}, TContext> => {

const mutationKey = ['vectorEmbeddingsSyncAuthorVectors'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>, {params: VectorEmbeddingsSyncAuthorVectorsParams}> = (props) => {
          const {params} = props ?? {};

          return  vectorEmbeddingsSyncAuthorVectors(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VectorEmbeddingsSyncAuthorVectorsMutationResult = NonNullable<Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>>
    
    export type VectorEmbeddingsSyncAuthorVectorsMutationError = HTTPValidationError

    /**
 * @summary Sync Author Vectors
 */
export const useVectorEmbeddingsSyncAuthorVectors = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>, TError,{params: VectorEmbeddingsSyncAuthorVectorsParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof vectorEmbeddingsSyncAuthorVectors>>,
        TError,
        {params: VectorEmbeddingsSyncAuthorVectorsParams},
        TContext
      > => {
      return useMutation(getVectorEmbeddingsSyncAuthorVectorsMutationOptions(options), queryClient);
    }
    /**
 * Sync vectors from both GitHub PRs and Jira issues.

This endpoint fetches data from configured integrations and generates
embeddings for semantic search and recommendation engine.

**Optional Parameters (via request body):**
- `sync_github`: Enable/disable GitHub sync (default: true)
- `sync_jira`: Enable/disable Jira sync (default: true)
- `github_max_prs_per_author`: Max PRs per author (default: 50)
- `jira_project_keys`: Specific Jira projects (default: all)
- `jira_max_issues`: Max issues per project (default: 100)
- `jira_include_closed`: Include closed issues (default: true)
- `jira_sync_comments`: Sync issue comments (default: true)

**Example request body:**
```json
{
    "sync_github": true,
    "sync_jira": true,
    "github_max_prs_per_author": 50,
    "jira_max_issues": 100
}
```
 * @summary Sync All Vectors
 */
export type vectorEmbeddingsSyncAllVectorsResponse200 = {
  data: SyncAllResponse
  status: 200
}

export type vectorEmbeddingsSyncAllVectorsResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type vectorEmbeddingsSyncAllVectorsResponseSuccess = (vectorEmbeddingsSyncAllVectorsResponse200) & {
  headers: Headers;
};
export type vectorEmbeddingsSyncAllVectorsResponseError = (vectorEmbeddingsSyncAllVectorsResponse422) & {
  headers: Headers;
};

export type vectorEmbeddingsSyncAllVectorsResponse = (vectorEmbeddingsSyncAllVectorsResponseSuccess | vectorEmbeddingsSyncAllVectorsResponseError)

export const getVectorEmbeddingsSyncAllVectorsUrl = () => {


  

  return `/api/v1/vectors/sync/all`
}

export const vectorEmbeddingsSyncAllVectors = async (syncAllRequestNull: SyncAllRequest | null, options?: RequestInit): Promise<vectorEmbeddingsSyncAllVectorsResponse> => {
  
  return customFetch<vectorEmbeddingsSyncAllVectorsResponse>(getVectorEmbeddingsSyncAllVectorsUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      syncAllRequestNull,)
  }
);}




export const getVectorEmbeddingsSyncAllVectorsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>, TError,{data: SyncAllRequest | null}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>, TError,{data: SyncAllRequest | null}, TContext> => {

const mutationKey = ['vectorEmbeddingsSyncAllVectors'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>, {data: SyncAllRequest | null}> = (props) => {
          const {data} = props ?? {};

          return  vectorEmbeddingsSyncAllVectors(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VectorEmbeddingsSyncAllVectorsMutationResult = NonNullable<Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>>
    export type VectorEmbeddingsSyncAllVectorsMutationBody = SyncAllRequest | null
    export type VectorEmbeddingsSyncAllVectorsMutationError = HTTPValidationError

    /**
 * @summary Sync All Vectors
 */
export const useVectorEmbeddingsSyncAllVectors = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>, TError,{data: SyncAllRequest | null}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof vectorEmbeddingsSyncAllVectors>>,
        TError,
        {data: SyncAllRequest | null},
        TContext
      > => {
      return useMutation(getVectorEmbeddingsSyncAllVectorsMutationOptions(options), queryClient);
    }
    /**
 * Search for similar PR contexts (GitHub only).
 * @summary Search Similar Prs
 */
export type vectorEmbeddingsSearchSimilarPrsResponse200 = {
  data: VectorEmbeddingsSearchSimilarPrs200
  status: 200
}

export type vectorEmbeddingsSearchSimilarPrsResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type vectorEmbeddingsSearchSimilarPrsResponseSuccess = (vectorEmbeddingsSearchSimilarPrsResponse200) & {
  headers: Headers;
};
export type vectorEmbeddingsSearchSimilarPrsResponseError = (vectorEmbeddingsSearchSimilarPrsResponse422) & {
  headers: Headers;
};

export type vectorEmbeddingsSearchSimilarPrsResponse = (vectorEmbeddingsSearchSimilarPrsResponseSuccess | vectorEmbeddingsSearchSimilarPrsResponseError)

export const getVectorEmbeddingsSearchSimilarPrsUrl = (params: VectorEmbeddingsSearchSimilarPrsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `/api/v1/vectors/search?${stringifiedParams}` : `/api/v1/vectors/search`
}

export const vectorEmbeddingsSearchSimilarPrs = async (params: VectorEmbeddingsSearchSimilarPrsParams, options?: RequestInit): Promise<vectorEmbeddingsSearchSimilarPrsResponse> => {
  
  return customFetch<vectorEmbeddingsSearchSimilarPrsResponse>(getVectorEmbeddingsSearchSimilarPrsUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
);}




export const getVectorEmbeddingsSearchSimilarPrsMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>, TError,{params: VectorEmbeddingsSearchSimilarPrsParams}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>, TError,{params: VectorEmbeddingsSearchSimilarPrsParams}, TContext> => {

const mutationKey = ['vectorEmbeddingsSearchSimilarPrs'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>, {params: VectorEmbeddingsSearchSimilarPrsParams}> = (props) => {
          const {params} = props ?? {};

          return  vectorEmbeddingsSearchSimilarPrs(params,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VectorEmbeddingsSearchSimilarPrsMutationResult = NonNullable<Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>>
    
    export type VectorEmbeddingsSearchSimilarPrsMutationError = HTTPValidationError

    /**
 * @summary Search Similar Prs
 */
export const useVectorEmbeddingsSearchSimilarPrs = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>, TError,{params: VectorEmbeddingsSearchSimilarPrsParams}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof vectorEmbeddingsSearchSimilarPrs>>,
        TError,
        {params: VectorEmbeddingsSearchSimilarPrsParams},
        TContext
      > => {
      return useMutation(getVectorEmbeddingsSearchSimilarPrsMutationOptions(options), queryClient);
    }
    /**
 * Unified semantic search across GitHub PRs and Jira issues.

This endpoint searches both GitHub and Jira vectors and returns
combined results sorted by relevance.

**Request body:**
- `query`: Search query text (required)
- `n_results`: Max results to return (default: 10)
- `search_github`: Include GitHub PRs (default: true)
- `search_jira`: Include Jira issues (default: true)
- `github_author_login`: Filter by GitHub author (optional)
- `jira_project_key`: Filter by Jira project (optional)
- `jira_assignee_id`: Filter by Jira assignee (optional)
 * @summary Unified Search
 */
export type vectorEmbeddingsUnifiedSearchResponse200 = {
  data: UnifiedSearchResponse
  status: 200
}

export type vectorEmbeddingsUnifiedSearchResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type vectorEmbeddingsUnifiedSearchResponseSuccess = (vectorEmbeddingsUnifiedSearchResponse200) & {
  headers: Headers;
};
export type vectorEmbeddingsUnifiedSearchResponseError = (vectorEmbeddingsUnifiedSearchResponse422) & {
  headers: Headers;
};

export type vectorEmbeddingsUnifiedSearchResponse = (vectorEmbeddingsUnifiedSearchResponseSuccess | vectorEmbeddingsUnifiedSearchResponseError)

export const getVectorEmbeddingsUnifiedSearchUrl = () => {


  

  return `/api/v1/vectors/search/unified`
}

export const vectorEmbeddingsUnifiedSearch = async (unifiedSearchRequest: UnifiedSearchRequest, options?: RequestInit): Promise<vectorEmbeddingsUnifiedSearchResponse> => {
  
  return customFetch<vectorEmbeddingsUnifiedSearchResponse>(getVectorEmbeddingsUnifiedSearchUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      unifiedSearchRequest,)
  }
);}




export const getVectorEmbeddingsUnifiedSearchMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>, TError,{data: UnifiedSearchRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
): UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>, TError,{data: UnifiedSearchRequest}, TContext> => {

const mutationKey = ['vectorEmbeddingsUnifiedSearch'];
const {mutation: mutationOptions, request: requestOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, request: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>, {data: UnifiedSearchRequest}> = (props) => {
          const {data} = props ?? {};

          return  vectorEmbeddingsUnifiedSearch(data,requestOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type VectorEmbeddingsUnifiedSearchMutationResult = NonNullable<Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>>
    export type VectorEmbeddingsUnifiedSearchMutationBody = UnifiedSearchRequest
    export type VectorEmbeddingsUnifiedSearchMutationError = HTTPValidationError

    /**
 * @summary Unified Search
 */
export const useVectorEmbeddingsUnifiedSearch = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>, TError,{data: UnifiedSearchRequest}, TContext>, request?: SecondParameter<typeof customFetch>}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof vectorEmbeddingsUnifiedSearch>>,
        TError,
        {data: UnifiedSearchRequest},
        TContext
      > => {
      return useMutation(getVectorEmbeddingsUnifiedSearchMutationOptions(options), queryClient);
    }
    