/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * FastAPI Backend Project
 * OpenAPI spec version: 0.1.0
 */
import {
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  ScoreGetBestFitsParams,
  ScoreProfile
} from '../../model';





/**
 * Get the top N resource profiles best suited for a given task.
Searches across all resource profiles with connected GitHub profiles and ranks them
by similarity to the task description based on their PR history.
Args:
    task: Task description to find best fits for
    top_n: Number of top resource profiles to return (default: 5)
Returns:
    List of tuples (user_id, score) sorted by score descending
 * @summary Get Best Fits
 */
export type scoreGetBestFitsResponse200 = {
  data: ScoreProfile[]
  status: 200
}

export type scoreGetBestFitsResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type scoreGetBestFitsResponseSuccess = (scoreGetBestFitsResponse200) & {
  headers: Headers;
};
export type scoreGetBestFitsResponseError = (scoreGetBestFitsResponse422) & {
  headers: Headers;
};

export type scoreGetBestFitsResponse = (scoreGetBestFitsResponseSuccess | scoreGetBestFitsResponseError)

export const getScoreGetBestFitsUrl = (params: ScoreGetBestFitsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/score/best-fits?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/score/best-fits`
}

export const scoreGetBestFits = async (params: ScoreGetBestFitsParams, options?: RequestInit): Promise<scoreGetBestFitsResponse> => {
  
  const res = await fetch(getScoreGetBestFitsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: scoreGetBestFitsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as scoreGetBestFitsResponse
}





export const getScoreGetBestFitsQueryKey = (params?: ScoreGetBestFitsParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/score/best-fits`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getScoreGetBestFitsQueryOptions = <TData = Awaited<ReturnType<typeof scoreGetBestFits>>, TError = HTTPValidationError>(params: ScoreGetBestFitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getScoreGetBestFitsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof scoreGetBestFits>>> = ({ signal }) => scoreGetBestFits(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type ScoreGetBestFitsQueryResult = NonNullable<Awaited<ReturnType<typeof scoreGetBestFits>>>
export type ScoreGetBestFitsQueryError = HTTPValidationError


export function useScoreGetBestFits<TData = Awaited<ReturnType<typeof scoreGetBestFits>>, TError = HTTPValidationError>(
 params: ScoreGetBestFitsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof scoreGetBestFits>>,
          TError,
          Awaited<ReturnType<typeof scoreGetBestFits>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScoreGetBestFits<TData = Awaited<ReturnType<typeof scoreGetBestFits>>, TError = HTTPValidationError>(
 params: ScoreGetBestFitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof scoreGetBestFits>>,
          TError,
          Awaited<ReturnType<typeof scoreGetBestFits>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useScoreGetBestFits<TData = Awaited<ReturnType<typeof scoreGetBestFits>>, TError = HTTPValidationError>(
 params: ScoreGetBestFitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Best Fits
 */

export function useScoreGetBestFits<TData = Awaited<ReturnType<typeof scoreGetBestFits>>, TError = HTTPValidationError>(
 params: ScoreGetBestFitsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof scoreGetBestFits>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getScoreGetBestFitsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




