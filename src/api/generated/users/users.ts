/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * FastAPI Backend Project
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  HTTPValidationError,
  Message,
  UpdatePassword,
  UserCreate,
  UserPublic,
  UserRegister,
  UserUpdate,
  UserUpdateMe,
  UsersPublic,
  UsersReadUsersParams
} from '../../model';





/**
 * Retrieve users. (Admin only)
 * @summary Read Users
 */
export type usersReadUsersResponse200 = {
  data: UsersPublic
  status: 200
}

export type usersReadUsersResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersReadUsersResponseSuccess = (usersReadUsersResponse200) & {
  headers: Headers;
};
export type usersReadUsersResponseError = (usersReadUsersResponse422) & {
  headers: Headers;
};

export type usersReadUsersResponse = (usersReadUsersResponseSuccess | usersReadUsersResponseError)

export const getUsersReadUsersUrl = (params?: UsersReadUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/users/?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/users/`
}

export const usersReadUsers = async (params?: UsersReadUsersParams, options?: RequestInit): Promise<usersReadUsersResponse> => {
  
  const res = await fetch(getUsersReadUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersReadUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersReadUsersResponse
}





export const getUsersReadUsersQueryKey = (params?: UsersReadUsersParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/users/`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getUsersReadUsersQueryOptions = <TData = Awaited<ReturnType<typeof usersReadUsers>>, TError = HTTPValidationError>(params?: UsersReadUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersReadUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUsers>>> = ({ signal }) => usersReadUsers(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersReadUsersQueryResult = NonNullable<Awaited<ReturnType<typeof usersReadUsers>>>
export type UsersReadUsersQueryError = HTTPValidationError


export function useUsersReadUsers<TData = Awaited<ReturnType<typeof usersReadUsers>>, TError = HTTPValidationError>(
 params: undefined |  UsersReadUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUsers>>,
          TError,
          Awaited<ReturnType<typeof usersReadUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUsers<TData = Awaited<ReturnType<typeof usersReadUsers>>, TError = HTTPValidationError>(
 params?: UsersReadUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUsers>>,
          TError,
          Awaited<ReturnType<typeof usersReadUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUsers<TData = Awaited<ReturnType<typeof usersReadUsers>>, TError = HTTPValidationError>(
 params?: UsersReadUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read Users
 */

export function useUsersReadUsers<TData = Awaited<ReturnType<typeof usersReadUsers>>, TError = HTTPValidationError>(
 params?: UsersReadUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersReadUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Create new user. (Admin only)
 * @summary Create User
 */
export type usersCreateUserResponse200 = {
  data: UserPublic
  status: 200
}

export type usersCreateUserResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersCreateUserResponseSuccess = (usersCreateUserResponse200) & {
  headers: Headers;
};
export type usersCreateUserResponseError = (usersCreateUserResponse422) & {
  headers: Headers;
};

export type usersCreateUserResponse = (usersCreateUserResponseSuccess | usersCreateUserResponseError)

export const getUsersCreateUserUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/`
}

export const usersCreateUser = async (userCreate: UserCreate, options?: RequestInit): Promise<usersCreateUserResponse> => {
  
  const res = await fetch(getUsersCreateUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userCreate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersCreateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersCreateUserResponse
}




export const getUsersCreateUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UserCreate}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UserCreate}, TContext> => {

const mutationKey = ['usersCreateUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersCreateUser>>, {data: UserCreate}> = (props) => {
          const {data} = props ?? {};

          return  usersCreateUser(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersCreateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersCreateUser>>>
    export type UsersCreateUserMutationBody = UserCreate
    export type UsersCreateUserMutationError = HTTPValidationError

    /**
 * @summary Create User
 */
export const useUsersCreateUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersCreateUser>>, TError,{data: UserCreate}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersCreateUser>>,
        TError,
        {data: UserCreate},
        TContext
      > => {
      return useMutation(getUsersCreateUserMutationOptions(options), queryClient);
    }
    /**
 * Get current user.
 * @summary Read User Me
 */
export type usersReadUserMeResponse200 = {
  data: UserPublic
  status: 200
}
    
export type usersReadUserMeResponseSuccess = (usersReadUserMeResponse200) & {
  headers: Headers;
};
;

export type usersReadUserMeResponse = (usersReadUserMeResponseSuccess)

export const getUsersReadUserMeUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/me`
}

export const usersReadUserMe = async ( options?: RequestInit): Promise<usersReadUserMeResponse> => {
  
  const res = await fetch(getUsersReadUserMeUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersReadUserMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersReadUserMeResponse
}





export const getUsersReadUserMeQueryKey = () => {
    return [
    `http://127.0.0.1:8000/api/v1/users/me`
    ] as const;
    }

    
export const getUsersReadUserMeQueryOptions = <TData = Awaited<ReturnType<typeof usersReadUserMe>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersReadUserMeQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUserMe>>> = ({ signal }) => usersReadUserMe({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersReadUserMeQueryResult = NonNullable<Awaited<ReturnType<typeof usersReadUserMe>>>
export type UsersReadUserMeQueryError = unknown


export function useUsersReadUserMe<TData = Awaited<ReturnType<typeof usersReadUserMe>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUserMe>>,
          TError,
          Awaited<ReturnType<typeof usersReadUserMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUserMe<TData = Awaited<ReturnType<typeof usersReadUserMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUserMe>>,
          TError,
          Awaited<ReturnType<typeof usersReadUserMe>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUserMe<TData = Awaited<ReturnType<typeof usersReadUserMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read User Me
 */

export function useUsersReadUserMe<TData = Awaited<ReturnType<typeof usersReadUserMe>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserMe>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersReadUserMeQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Delete own user.
 * @summary Delete User Me
 */
export type usersDeleteUserMeResponse200 = {
  data: Message
  status: 200
}
    
export type usersDeleteUserMeResponseSuccess = (usersDeleteUserMeResponse200) & {
  headers: Headers;
};
;

export type usersDeleteUserMeResponse = (usersDeleteUserMeResponseSuccess)

export const getUsersDeleteUserMeUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/me`
}

export const usersDeleteUserMe = async ( options?: RequestInit): Promise<usersDeleteUserMeResponse> => {
  
  const res = await fetch(getUsersDeleteUserMeUrl(),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersDeleteUserMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersDeleteUserMeResponse
}




export const getUsersDeleteUserMeMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserMe>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserMe>>, TError,void, TContext> => {

const mutationKey = ['usersDeleteUserMe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUserMe>>, void> = () => {
          

          return  usersDeleteUserMe(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUserMe>>>
    
    export type UsersDeleteUserMeMutationError = unknown

    /**
 * @summary Delete User Me
 */
export const useUsersDeleteUserMe = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUserMe>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUserMe>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getUsersDeleteUserMeMutationOptions(options), queryClient);
    }
    /**
 * Update own user.
 * @summary Update User Me
 */
export type usersUpdateUserMeResponse200 = {
  data: UserPublic
  status: 200
}

export type usersUpdateUserMeResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersUpdateUserMeResponseSuccess = (usersUpdateUserMeResponse200) & {
  headers: Headers;
};
export type usersUpdateUserMeResponseError = (usersUpdateUserMeResponse422) & {
  headers: Headers;
};

export type usersUpdateUserMeResponse = (usersUpdateUserMeResponseSuccess | usersUpdateUserMeResponseError)

export const getUsersUpdateUserMeUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/me`
}

export const usersUpdateUserMe = async (userUpdateMe: UserUpdateMe, options?: RequestInit): Promise<usersUpdateUserMeResponse> => {
  
  const res = await fetch(getUsersUpdateUserMeUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userUpdateMe,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersUpdateUserMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersUpdateUserMeResponse
}




export const getUsersUpdateUserMeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUserMe>>, TError,{data: UserUpdateMe}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUserMe>>, TError,{data: UserUpdateMe}, TContext> => {

const mutationKey = ['usersUpdateUserMe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateUserMe>>, {data: UserUpdateMe}> = (props) => {
          const {data} = props ?? {};

          return  usersUpdateUserMe(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateUserMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateUserMe>>>
    export type UsersUpdateUserMeMutationBody = UserUpdateMe
    export type UsersUpdateUserMeMutationError = HTTPValidationError

    /**
 * @summary Update User Me
 */
export const useUsersUpdateUserMe = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUserMe>>, TError,{data: UserUpdateMe}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateUserMe>>,
        TError,
        {data: UserUpdateMe},
        TContext
      > => {
      return useMutation(getUsersUpdateUserMeMutationOptions(options), queryClient);
    }
    /**
 * Update own password.
 * @summary Update Password Me
 */
export type usersUpdatePasswordMeResponse200 = {
  data: Message
  status: 200
}

export type usersUpdatePasswordMeResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersUpdatePasswordMeResponseSuccess = (usersUpdatePasswordMeResponse200) & {
  headers: Headers;
};
export type usersUpdatePasswordMeResponseError = (usersUpdatePasswordMeResponse422) & {
  headers: Headers;
};

export type usersUpdatePasswordMeResponse = (usersUpdatePasswordMeResponseSuccess | usersUpdatePasswordMeResponseError)

export const getUsersUpdatePasswordMeUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/me/password`
}

export const usersUpdatePasswordMe = async (updatePassword: UpdatePassword, options?: RequestInit): Promise<usersUpdatePasswordMeResponse> => {
  
  const res = await fetch(getUsersUpdatePasswordMeUrl(),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      updatePassword,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersUpdatePasswordMeResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersUpdatePasswordMeResponse
}




export const getUsersUpdatePasswordMeMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdatePasswordMe>>, TError,{data: UpdatePassword}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdatePasswordMe>>, TError,{data: UpdatePassword}, TContext> => {

const mutationKey = ['usersUpdatePasswordMe'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdatePasswordMe>>, {data: UpdatePassword}> = (props) => {
          const {data} = props ?? {};

          return  usersUpdatePasswordMe(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdatePasswordMeMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdatePasswordMe>>>
    export type UsersUpdatePasswordMeMutationBody = UpdatePassword
    export type UsersUpdatePasswordMeMutationError = HTTPValidationError

    /**
 * @summary Update Password Me
 */
export const useUsersUpdatePasswordMe = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdatePasswordMe>>, TError,{data: UpdatePassword}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdatePasswordMe>>,
        TError,
        {data: UpdatePassword},
        TContext
      > => {
      return useMutation(getUsersUpdatePasswordMeMutationOptions(options), queryClient);
    }
    /**
 * Create new user without the need to be logged in.
 * @summary Register User
 */
export type usersRegisterUserResponse200 = {
  data: UserPublic
  status: 200
}

export type usersRegisterUserResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersRegisterUserResponseSuccess = (usersRegisterUserResponse200) & {
  headers: Headers;
};
export type usersRegisterUserResponseError = (usersRegisterUserResponse422) & {
  headers: Headers;
};

export type usersRegisterUserResponse = (usersRegisterUserResponseSuccess | usersRegisterUserResponseError)

export const getUsersRegisterUserUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/users/signup`
}

export const usersRegisterUser = async (userRegister: UserRegister, options?: RequestInit): Promise<usersRegisterUserResponse> => {
  
  const res = await fetch(getUsersRegisterUserUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userRegister,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersRegisterUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersRegisterUserResponse
}




export const getUsersRegisterUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRegisterUser>>, TError,{data: UserRegister}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersRegisterUser>>, TError,{data: UserRegister}, TContext> => {

const mutationKey = ['usersRegisterUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersRegisterUser>>, {data: UserRegister}> = (props) => {
          const {data} = props ?? {};

          return  usersRegisterUser(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersRegisterUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersRegisterUser>>>
    export type UsersRegisterUserMutationBody = UserRegister
    export type UsersRegisterUserMutationError = HTTPValidationError

    /**
 * @summary Register User
 */
export const useUsersRegisterUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersRegisterUser>>, TError,{data: UserRegister}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersRegisterUser>>,
        TError,
        {data: UserRegister},
        TContext
      > => {
      return useMutation(getUsersRegisterUserMutationOptions(options), queryClient);
    }
    /**
 * Get a specific user by id. (Admin/Moderator can view any user)
 * @summary Read User By Id
 */
export type usersReadUserByIdResponse200 = {
  data: UserPublic
  status: 200
}

export type usersReadUserByIdResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersReadUserByIdResponseSuccess = (usersReadUserByIdResponse200) & {
  headers: Headers;
};
export type usersReadUserByIdResponseError = (usersReadUserByIdResponse422) & {
  headers: Headers;
};

export type usersReadUserByIdResponse = (usersReadUserByIdResponseSuccess | usersReadUserByIdResponseError)

export const getUsersReadUserByIdUrl = (userId: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/users/${userId}`
}

export const usersReadUserById = async (userId: string, options?: RequestInit): Promise<usersReadUserByIdResponse> => {
  
  const res = await fetch(getUsersReadUserByIdUrl(userId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersReadUserByIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersReadUserByIdResponse
}





export const getUsersReadUserByIdQueryKey = (userId: string,) => {
    return [
    `http://127.0.0.1:8000/api/v1/users/${userId}`
    ] as const;
    }

    
export const getUsersReadUserByIdQueryOptions = <TData = Awaited<ReturnType<typeof usersReadUserById>>, TError = HTTPValidationError>(userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getUsersReadUserByIdQueryKey(userId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof usersReadUserById>>> = ({ signal }) => usersReadUserById(userId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(userId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type UsersReadUserByIdQueryResult = NonNullable<Awaited<ReturnType<typeof usersReadUserById>>>
export type UsersReadUserByIdQueryError = HTTPValidationError


export function useUsersReadUserById<TData = Awaited<ReturnType<typeof usersReadUserById>>, TError = HTTPValidationError>(
 userId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUserById>>,
          TError,
          Awaited<ReturnType<typeof usersReadUserById>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUserById<TData = Awaited<ReturnType<typeof usersReadUserById>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof usersReadUserById>>,
          TError,
          Awaited<ReturnType<typeof usersReadUserById>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useUsersReadUserById<TData = Awaited<ReturnType<typeof usersReadUserById>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Read User By Id
 */

export function useUsersReadUserById<TData = Awaited<ReturnType<typeof usersReadUserById>>, TError = HTTPValidationError>(
 userId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof usersReadUserById>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getUsersReadUserByIdQueryOptions(userId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Update a user. (Admin only)
 * @summary Update User
 */
export type usersUpdateUserResponse200 = {
  data: UserPublic
  status: 200
}

export type usersUpdateUserResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersUpdateUserResponseSuccess = (usersUpdateUserResponse200) & {
  headers: Headers;
};
export type usersUpdateUserResponseError = (usersUpdateUserResponse422) & {
  headers: Headers;
};

export type usersUpdateUserResponse = (usersUpdateUserResponseSuccess | usersUpdateUserResponseError)

export const getUsersUpdateUserUrl = (userId: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/users/${userId}`
}

export const usersUpdateUser = async (userId: string,
    userUpdate: UserUpdate, options?: RequestInit): Promise<usersUpdateUserResponse> => {
  
  const res = await fetch(getUsersUpdateUserUrl(userId),
  {      
    ...options,
    method: 'PATCH',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      userUpdate,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersUpdateUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersUpdateUserResponse
}




export const getUsersUpdateUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UserUpdate}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UserUpdate}, TContext> => {

const mutationKey = ['usersUpdateUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersUpdateUser>>, {userId: string;data: UserUpdate}> = (props) => {
          const {userId,data} = props ?? {};

          return  usersUpdateUser(userId,data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersUpdateUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersUpdateUser>>>
    export type UsersUpdateUserMutationBody = UserUpdate
    export type UsersUpdateUserMutationError = HTTPValidationError

    /**
 * @summary Update User
 */
export const useUsersUpdateUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersUpdateUser>>, TError,{userId: string;data: UserUpdate}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersUpdateUser>>,
        TError,
        {userId: string;data: UserUpdate},
        TContext
      > => {
      return useMutation(getUsersUpdateUserMutationOptions(options), queryClient);
    }
    /**
 * Delete a user. (Admin only)
 * @summary Delete User
 */
export type usersDeleteUserResponse200 = {
  data: Message
  status: 200
}

export type usersDeleteUserResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type usersDeleteUserResponseSuccess = (usersDeleteUserResponse200) & {
  headers: Headers;
};
export type usersDeleteUserResponseError = (usersDeleteUserResponse422) & {
  headers: Headers;
};

export type usersDeleteUserResponse = (usersDeleteUserResponseSuccess | usersDeleteUserResponseError)

export const getUsersDeleteUserUrl = (userId: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/users/${userId}`
}

export const usersDeleteUser = async (userId: string, options?: RequestInit): Promise<usersDeleteUserResponse> => {
  
  const res = await fetch(getUsersDeleteUserUrl(userId),
  {      
    ...options,
    method: 'DELETE'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: usersDeleteUserResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as usersDeleteUserResponse
}




export const getUsersDeleteUserMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext> => {

const mutationKey = ['usersDeleteUser'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof usersDeleteUser>>, {userId: string}> = (props) => {
          const {userId} = props ?? {};

          return  usersDeleteUser(userId,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type UsersDeleteUserMutationResult = NonNullable<Awaited<ReturnType<typeof usersDeleteUser>>>
    
    export type UsersDeleteUserMutationError = HTTPValidationError

    /**
 * @summary Delete User
 */
export const useUsersDeleteUser = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof usersDeleteUser>>, TError,{userId: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof usersDeleteUser>>,
        TError,
        {userId: string},
        TContext
      > => {
      return useMutation(getUsersDeleteUserMutationOptions(options), queryClient);
    }
    