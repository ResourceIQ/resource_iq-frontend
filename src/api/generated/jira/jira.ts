/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * FastAPI Backend Project
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation,
  useQuery
} from '@tanstack/react-query';
import type {
  DataTag,
  DefinedInitialDataOptions,
  DefinedUseQueryResult,
  MutationFunction,
  QueryClient,
  QueryFunction,
  QueryKey,
  UndefinedInitialDataOptions,
  UseMutationOptions,
  UseMutationResult,
  UseQueryOptions,
  UseQueryResult
} from '@tanstack/react-query';

import type {
  DeveloperWorkload,
  HTTPValidationError,
  JiraAuthCallbackResponse,
  JiraAuthConnectResponse,
  JiraGetAllJiraUsersParams,
  JiraGetIssueVector200,
  JiraGetIssueVectors200Item,
  JiraGetIssueVectorsParams,
  JiraGetProjectUsers200Item,
  JiraGetProjectUsersParams,
  JiraGetProjects200Item,
  JiraGetUserByAccountId200,
  JiraIssueContent,
  JiraJiraOauthCallbackParams,
  JiraJiraWebhook200,
  JiraSearchSimilarIssues200Item,
  JiraSearchSimilarIssuesParams,
  JiraSyncRequest,
  JiraSyncResponse,
  JiraTestWebhookEndpoint200,
  JiraUser
} from '../../model';





/**
 * Initiate Atlassian OAuth (3LO) for Jira Cloud.
 * @summary Connect Jira
 */
export type jiraConnectJiraResponse200 = {
  data: JiraAuthConnectResponse
  status: 200
}
    
export type jiraConnectJiraResponseSuccess = (jiraConnectJiraResponse200) & {
  headers: Headers;
};
;

export type jiraConnectJiraResponse = (jiraConnectJiraResponseSuccess)

export const getJiraConnectJiraUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/auth/connect`
}

export const jiraConnectJira = async ( options?: RequestInit): Promise<jiraConnectJiraResponse> => {
  
  const res = await fetch(getJiraConnectJiraUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraConnectJiraResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraConnectJiraResponse
}





export const getJiraConnectJiraQueryKey = () => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/auth/connect`
    ] as const;
    }

    
export const getJiraConnectJiraQueryOptions = <TData = Awaited<ReturnType<typeof jiraConnectJira>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraConnectJiraQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraConnectJira>>> = ({ signal }) => jiraConnectJira({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraConnectJiraQueryResult = NonNullable<Awaited<ReturnType<typeof jiraConnectJira>>>
export type JiraConnectJiraQueryError = unknown


export function useJiraConnectJira<TData = Awaited<ReturnType<typeof jiraConnectJira>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraConnectJira>>,
          TError,
          Awaited<ReturnType<typeof jiraConnectJira>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraConnectJira<TData = Awaited<ReturnType<typeof jiraConnectJira>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraConnectJira>>,
          TError,
          Awaited<ReturnType<typeof jiraConnectJira>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraConnectJira<TData = Awaited<ReturnType<typeof jiraConnectJira>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Connect Jira
 */

export function useJiraConnectJira<TData = Awaited<ReturnType<typeof jiraConnectJira>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraConnectJira>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraConnectJiraQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Handle Atlassian OAuth callback, exchange code, and persist tokens.
 * @summary Jira Oauth Callback
 */
export type jiraJiraOauthCallbackResponse200 = {
  data: JiraAuthCallbackResponse
  status: 200
}

export type jiraJiraOauthCallbackResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraJiraOauthCallbackResponseSuccess = (jiraJiraOauthCallbackResponse200) & {
  headers: Headers;
};
export type jiraJiraOauthCallbackResponseError = (jiraJiraOauthCallbackResponse422) & {
  headers: Headers;
};

export type jiraJiraOauthCallbackResponse = (jiraJiraOauthCallbackResponseSuccess | jiraJiraOauthCallbackResponseError)

export const getJiraJiraOauthCallbackUrl = (params: JiraJiraOauthCallbackParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/jira/auth/callback?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/jira/auth/callback`
}

export const jiraJiraOauthCallback = async (params: JiraJiraOauthCallbackParams, options?: RequestInit): Promise<jiraJiraOauthCallbackResponse> => {
  
  const res = await fetch(getJiraJiraOauthCallbackUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraJiraOauthCallbackResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraJiraOauthCallbackResponse
}





export const getJiraJiraOauthCallbackQueryKey = (params?: JiraJiraOauthCallbackParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/auth/callback`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getJiraJiraOauthCallbackQueryOptions = <TData = Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError = HTTPValidationError>(params: JiraJiraOauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraJiraOauthCallbackQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraJiraOauthCallback>>> = ({ signal }) => jiraJiraOauthCallback(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraJiraOauthCallbackQueryResult = NonNullable<Awaited<ReturnType<typeof jiraJiraOauthCallback>>>
export type JiraJiraOauthCallbackQueryError = HTTPValidationError


export function useJiraJiraOauthCallback<TData = Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError = HTTPValidationError>(
 params: JiraJiraOauthCallbackParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraJiraOauthCallback>>,
          TError,
          Awaited<ReturnType<typeof jiraJiraOauthCallback>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraJiraOauthCallback<TData = Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError = HTTPValidationError>(
 params: JiraJiraOauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraJiraOauthCallback>>,
          TError,
          Awaited<ReturnType<typeof jiraJiraOauthCallback>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraJiraOauthCallback<TData = Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError = HTTPValidationError>(
 params: JiraJiraOauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Jira Oauth Callback
 */

export function useJiraJiraOauthCallback<TData = Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError = HTTPValidationError>(
 params: JiraJiraOauthCallbackParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraJiraOauthCallback>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraJiraOauthCallbackQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get all accessible Jira projects.
 * @summary Get Projects
 */
export type jiraGetProjectsResponse200 = {
  data: JiraGetProjects200Item[]
  status: 200
}
    
export type jiraGetProjectsResponseSuccess = (jiraGetProjectsResponse200) & {
  headers: Headers;
};
;

export type jiraGetProjectsResponse = (jiraGetProjectsResponseSuccess)

export const getJiraGetProjectsUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/projects`
}

export const jiraGetProjects = async ( options?: RequestInit): Promise<jiraGetProjectsResponse> => {
  
  const res = await fetch(getJiraGetProjectsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetProjectsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetProjectsResponse
}





export const getJiraGetProjectsQueryKey = () => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/projects`
    ] as const;
    }

    
export const getJiraGetProjectsQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetProjects>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetProjectsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetProjects>>> = ({ signal }) => jiraGetProjects({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetProjectsQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetProjects>>>
export type JiraGetProjectsQueryError = unknown


export function useJiraGetProjects<TData = Awaited<ReturnType<typeof jiraGetProjects>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetProjects>>,
          TError,
          Awaited<ReturnType<typeof jiraGetProjects>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetProjects<TData = Awaited<ReturnType<typeof jiraGetProjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetProjects>>,
          TError,
          Awaited<ReturnType<typeof jiraGetProjects>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetProjects<TData = Awaited<ReturnType<typeof jiraGetProjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Projects
 */

export function useJiraGetProjects<TData = Awaited<ReturnType<typeof jiraGetProjects>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjects>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetProjectsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get all users from Jira Cloud.
Returns all Atlassian account users (not apps/bots).
 * @summary Get All Jira Users
 */
export type jiraGetAllJiraUsersResponse200 = {
  data: JiraUser[]
  status: 200
}

export type jiraGetAllJiraUsersResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetAllJiraUsersResponseSuccess = (jiraGetAllJiraUsersResponse200) & {
  headers: Headers;
};
export type jiraGetAllJiraUsersResponseError = (jiraGetAllJiraUsersResponse422) & {
  headers: Headers;
};

export type jiraGetAllJiraUsersResponse = (jiraGetAllJiraUsersResponseSuccess | jiraGetAllJiraUsersResponseError)

export const getJiraGetAllJiraUsersUrl = (params?: JiraGetAllJiraUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/jira/users?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/jira/users`
}

export const jiraGetAllJiraUsers = async (params?: JiraGetAllJiraUsersParams, options?: RequestInit): Promise<jiraGetAllJiraUsersResponse> => {
  
  const res = await fetch(getJiraGetAllJiraUsersUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetAllJiraUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetAllJiraUsersResponse
}





export const getJiraGetAllJiraUsersQueryKey = (params?: JiraGetAllJiraUsersParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/users`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getJiraGetAllJiraUsersQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError = HTTPValidationError>(params?: JiraGetAllJiraUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetAllJiraUsersQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>> = ({ signal }) => jiraGetAllJiraUsers(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetAllJiraUsersQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>>
export type JiraGetAllJiraUsersQueryError = HTTPValidationError


export function useJiraGetAllJiraUsers<TData = Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError = HTTPValidationError>(
 params: undefined |  JiraGetAllJiraUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetAllJiraUsers>>,
          TError,
          Awaited<ReturnType<typeof jiraGetAllJiraUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetAllJiraUsers<TData = Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError = HTTPValidationError>(
 params?: JiraGetAllJiraUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetAllJiraUsers>>,
          TError,
          Awaited<ReturnType<typeof jiraGetAllJiraUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetAllJiraUsers<TData = Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError = HTTPValidationError>(
 params?: JiraGetAllJiraUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Jira Users
 */

export function useJiraGetAllJiraUsers<TData = Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError = HTTPValidationError>(
 params?: JiraGetAllJiraUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllJiraUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetAllJiraUsersQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get all users assignable to issues in a specific Jira project.
 * @summary Get Project Users
 */
export type jiraGetProjectUsersResponse200 = {
  data: JiraGetProjectUsers200Item[]
  status: 200
}

export type jiraGetProjectUsersResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetProjectUsersResponseSuccess = (jiraGetProjectUsersResponse200) & {
  headers: Headers;
};
export type jiraGetProjectUsersResponseError = (jiraGetProjectUsersResponse422) & {
  headers: Headers;
};

export type jiraGetProjectUsersResponse = (jiraGetProjectUsersResponseSuccess | jiraGetProjectUsersResponseError)

export const getJiraGetProjectUsersUrl = (projectKey: string,
    params?: JiraGetProjectUsersParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/jira/projects/${projectKey}/users?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/jira/projects/${projectKey}/users`
}

export const jiraGetProjectUsers = async (projectKey: string,
    params?: JiraGetProjectUsersParams, options?: RequestInit): Promise<jiraGetProjectUsersResponse> => {
  
  const res = await fetch(getJiraGetProjectUsersUrl(projectKey,params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetProjectUsersResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetProjectUsersResponse
}





export const getJiraGetProjectUsersQueryKey = (projectKey: string,
    params?: JiraGetProjectUsersParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/projects/${projectKey}/users`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getJiraGetProjectUsersQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError = HTTPValidationError>(projectKey: string,
    params?: JiraGetProjectUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetProjectUsersQueryKey(projectKey,params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetProjectUsers>>> = ({ signal }) => jiraGetProjectUsers(projectKey,params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(projectKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetProjectUsersQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetProjectUsers>>>
export type JiraGetProjectUsersQueryError = HTTPValidationError


export function useJiraGetProjectUsers<TData = Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError = HTTPValidationError>(
 projectKey: string,
    params: undefined |  JiraGetProjectUsersParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetProjectUsers>>,
          TError,
          Awaited<ReturnType<typeof jiraGetProjectUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetProjectUsers<TData = Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError = HTTPValidationError>(
 projectKey: string,
    params?: JiraGetProjectUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetProjectUsers>>,
          TError,
          Awaited<ReturnType<typeof jiraGetProjectUsers>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetProjectUsers<TData = Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError = HTTPValidationError>(
 projectKey: string,
    params?: JiraGetProjectUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Project Users
 */

export function useJiraGetProjectUsers<TData = Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError = HTTPValidationError>(
 projectKey: string,
    params?: JiraGetProjectUsersParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetProjectUsers>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetProjectUsersQueryOptions(projectKey,params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get a specific Jira user by their account ID.
 * @summary Get User By Account Id
 */
export type jiraGetUserByAccountIdResponse200 = {
  data: JiraGetUserByAccountId200
  status: 200
}

export type jiraGetUserByAccountIdResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetUserByAccountIdResponseSuccess = (jiraGetUserByAccountIdResponse200) & {
  headers: Headers;
};
export type jiraGetUserByAccountIdResponseError = (jiraGetUserByAccountIdResponse422) & {
  headers: Headers;
};

export type jiraGetUserByAccountIdResponse = (jiraGetUserByAccountIdResponseSuccess | jiraGetUserByAccountIdResponseError)

export const getJiraGetUserByAccountIdUrl = (accountId: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/jira/users/${accountId}`
}

export const jiraGetUserByAccountId = async (accountId: string, options?: RequestInit): Promise<jiraGetUserByAccountIdResponse> => {
  
  const res = await fetch(getJiraGetUserByAccountIdUrl(accountId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetUserByAccountIdResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetUserByAccountIdResponse
}





export const getJiraGetUserByAccountIdQueryKey = (accountId: string,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/users/${accountId}`
    ] as const;
    }

    
export const getJiraGetUserByAccountIdQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError = HTTPValidationError>(accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetUserByAccountIdQueryKey(accountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetUserByAccountId>>> = ({ signal }) => jiraGetUserByAccountId(accountId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(accountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetUserByAccountIdQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetUserByAccountId>>>
export type JiraGetUserByAccountIdQueryError = HTTPValidationError


export function useJiraGetUserByAccountId<TData = Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError = HTTPValidationError>(
 accountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetUserByAccountId>>,
          TError,
          Awaited<ReturnType<typeof jiraGetUserByAccountId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetUserByAccountId<TData = Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError = HTTPValidationError>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetUserByAccountId>>,
          TError,
          Awaited<ReturnType<typeof jiraGetUserByAccountId>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetUserByAccountId<TData = Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError = HTTPValidationError>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get User By Account Id
 */

export function useJiraGetUserByAccountId<TData = Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError = HTTPValidationError>(
 accountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetUserByAccountId>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetUserByAccountIdQueryOptions(accountId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Trigger a manual sync of Jira issues.
This endpoint satisfies the requirement for Workplace Administrators
to initiate a manual sync (POST /api/v1/jira/sync).
 * @summary Sync Issues
 */
export type jiraSyncIssuesResponse200 = {
  data: JiraSyncResponse
  status: 200
}

export type jiraSyncIssuesResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraSyncIssuesResponseSuccess = (jiraSyncIssuesResponse200) & {
  headers: Headers;
};
export type jiraSyncIssuesResponseError = (jiraSyncIssuesResponse422) & {
  headers: Headers;
};

export type jiraSyncIssuesResponse = (jiraSyncIssuesResponseSuccess | jiraSyncIssuesResponseError)

export const getJiraSyncIssuesUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/sync`
}

export const jiraSyncIssues = async (jiraSyncRequest: JiraSyncRequest, options?: RequestInit): Promise<jiraSyncIssuesResponse> => {
  
  const res = await fetch(getJiraSyncIssuesUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      jiraSyncRequest,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraSyncIssuesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraSyncIssuesResponse
}




export const getJiraSyncIssuesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraSyncIssues>>, TError,{data: JiraSyncRequest}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof jiraSyncIssues>>, TError,{data: JiraSyncRequest}, TContext> => {

const mutationKey = ['jiraSyncIssues'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jiraSyncIssues>>, {data: JiraSyncRequest}> = (props) => {
          const {data} = props ?? {};

          return  jiraSyncIssues(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type JiraSyncIssuesMutationResult = NonNullable<Awaited<ReturnType<typeof jiraSyncIssues>>>
    export type JiraSyncIssuesMutationBody = JiraSyncRequest
    export type JiraSyncIssuesMutationError = HTTPValidationError

    /**
 * @summary Sync Issues
 */
export const useJiraSyncIssues = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraSyncIssues>>, TError,{data: JiraSyncRequest}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof jiraSyncIssues>>,
        TError,
        {data: JiraSyncRequest},
        TContext
      > => {
      return useMutation(getJiraSyncIssuesMutationOptions(options), queryClient);
    }
    /**
 * Get synced Jira issue vectors from the database.
Returns vector metadata without the actual embeddings.
 * @summary Get Issue Vectors
 */
export type jiraGetIssueVectorsResponse200 = {
  data: JiraGetIssueVectors200Item[]
  status: 200
}

export type jiraGetIssueVectorsResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetIssueVectorsResponseSuccess = (jiraGetIssueVectorsResponse200) & {
  headers: Headers;
};
export type jiraGetIssueVectorsResponseError = (jiraGetIssueVectorsResponse422) & {
  headers: Headers;
};

export type jiraGetIssueVectorsResponse = (jiraGetIssueVectorsResponseSuccess | jiraGetIssueVectorsResponseError)

export const getJiraGetIssueVectorsUrl = (params?: JiraGetIssueVectorsParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/jira/vectors?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/jira/vectors`
}

export const jiraGetIssueVectors = async (params?: JiraGetIssueVectorsParams, options?: RequestInit): Promise<jiraGetIssueVectorsResponse> => {
  
  const res = await fetch(getJiraGetIssueVectorsUrl(params),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetIssueVectorsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetIssueVectorsResponse
}





export const getJiraGetIssueVectorsQueryKey = (params?: JiraGetIssueVectorsParams,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/vectors`, ...(params ? [params] : [])
    ] as const;
    }

    
export const getJiraGetIssueVectorsQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError = HTTPValidationError>(params?: JiraGetIssueVectorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetIssueVectorsQueryKey(params);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetIssueVectors>>> = ({ signal }) => jiraGetIssueVectors(params, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetIssueVectorsQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetIssueVectors>>>
export type JiraGetIssueVectorsQueryError = HTTPValidationError


export function useJiraGetIssueVectors<TData = Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError = HTTPValidationError>(
 params: undefined |  JiraGetIssueVectorsParams, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueVectors>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueVectors>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueVectors<TData = Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError = HTTPValidationError>(
 params?: JiraGetIssueVectorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueVectors>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueVectors>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueVectors<TData = Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError = HTTPValidationError>(
 params?: JiraGetIssueVectorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Issue Vectors
 */

export function useJiraGetIssueVectors<TData = Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError = HTTPValidationError>(
 params?: JiraGetIssueVectorsParams, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVectors>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetIssueVectorsQueryOptions(params,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Get a specific Jira issue vector by key.
 * @summary Get Issue Vector
 */
export type jiraGetIssueVectorResponse200 = {
  data: JiraGetIssueVector200
  status: 200
}

export type jiraGetIssueVectorResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetIssueVectorResponseSuccess = (jiraGetIssueVectorResponse200) & {
  headers: Headers;
};
export type jiraGetIssueVectorResponseError = (jiraGetIssueVectorResponse422) & {
  headers: Headers;
};

export type jiraGetIssueVectorResponse = (jiraGetIssueVectorResponseSuccess | jiraGetIssueVectorResponseError)

export const getJiraGetIssueVectorUrl = (issueKey: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/jira/vectors/${issueKey}`
}

export const jiraGetIssueVector = async (issueKey: string, options?: RequestInit): Promise<jiraGetIssueVectorResponse> => {
  
  const res = await fetch(getJiraGetIssueVectorUrl(issueKey),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetIssueVectorResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetIssueVectorResponse
}





export const getJiraGetIssueVectorQueryKey = (issueKey: string,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/vectors/${issueKey}`
    ] as const;
    }

    
export const getJiraGetIssueVectorQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetIssueVector>>, TError = HTTPValidationError>(issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetIssueVectorQueryKey(issueKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetIssueVector>>> = ({ signal }) => jiraGetIssueVector(issueKey, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(issueKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetIssueVectorQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetIssueVector>>>
export type JiraGetIssueVectorQueryError = HTTPValidationError


export function useJiraGetIssueVector<TData = Awaited<ReturnType<typeof jiraGetIssueVector>>, TError = HTTPValidationError>(
 issueKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueVector>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueVector>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueVector<TData = Awaited<ReturnType<typeof jiraGetIssueVector>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueVector>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueVector>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueVector<TData = Awaited<ReturnType<typeof jiraGetIssueVector>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Issue Vector
 */

export function useJiraGetIssueVector<TData = Awaited<ReturnType<typeof jiraGetIssueVector>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueVector>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetIssueVectorQueryOptions(issueKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Calculate and return the Jira workload for a specific user by account ID.
Useful for the recommendation engine.
 * @summary Get Workload By Account
 */
export type jiraGetWorkloadByAccountResponse200 = {
  data: DeveloperWorkload
  status: 200
}

export type jiraGetWorkloadByAccountResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetWorkloadByAccountResponseSuccess = (jiraGetWorkloadByAccountResponse200) & {
  headers: Headers;
};
export type jiraGetWorkloadByAccountResponseError = (jiraGetWorkloadByAccountResponse422) & {
  headers: Headers;
};

export type jiraGetWorkloadByAccountResponse = (jiraGetWorkloadByAccountResponseSuccess | jiraGetWorkloadByAccountResponseError)

export const getJiraGetWorkloadByAccountUrl = (jiraAccountId: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/jira/workload/${jiraAccountId}`
}

export const jiraGetWorkloadByAccount = async (jiraAccountId: string, options?: RequestInit): Promise<jiraGetWorkloadByAccountResponse> => {
  
  const res = await fetch(getJiraGetWorkloadByAccountUrl(jiraAccountId),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetWorkloadByAccountResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetWorkloadByAccountResponse
}





export const getJiraGetWorkloadByAccountQueryKey = (jiraAccountId: string,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/workload/${jiraAccountId}`
    ] as const;
    }

    
export const getJiraGetWorkloadByAccountQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError = HTTPValidationError>(jiraAccountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetWorkloadByAccountQueryKey(jiraAccountId);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>> = ({ signal }) => jiraGetWorkloadByAccount(jiraAccountId, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(jiraAccountId), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetWorkloadByAccountQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>>
export type JiraGetWorkloadByAccountQueryError = HTTPValidationError


export function useJiraGetWorkloadByAccount<TData = Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError = HTTPValidationError>(
 jiraAccountId: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>,
          TError,
          Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetWorkloadByAccount<TData = Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError = HTTPValidationError>(
 jiraAccountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>,
          TError,
          Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetWorkloadByAccount<TData = Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError = HTTPValidationError>(
 jiraAccountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Workload By Account
 */

export function useJiraGetWorkloadByAccount<TData = Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError = HTTPValidationError>(
 jiraAccountId: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetWorkloadByAccount>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetWorkloadByAccountQueryOptions(jiraAccountId,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Calculate and return workloads for all developers with Jira connected.
Useful for the recommendation engine to find the best-fit developer.
 * @summary Get All Workloads
 */
export type jiraGetAllWorkloadsResponse200 = {
  data: DeveloperWorkload[]
  status: 200
}
    
export type jiraGetAllWorkloadsResponseSuccess = (jiraGetAllWorkloadsResponse200) & {
  headers: Headers;
};
;

export type jiraGetAllWorkloadsResponse = (jiraGetAllWorkloadsResponseSuccess)

export const getJiraGetAllWorkloadsUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/workloads`
}

export const jiraGetAllWorkloads = async ( options?: RequestInit): Promise<jiraGetAllWorkloadsResponse> => {
  
  const res = await fetch(getJiraGetAllWorkloadsUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetAllWorkloadsResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetAllWorkloadsResponse
}





export const getJiraGetAllWorkloadsQueryKey = () => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/workloads`
    ] as const;
    }

    
export const getJiraGetAllWorkloadsQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetAllWorkloadsQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetAllWorkloads>>> = ({ signal }) => jiraGetAllWorkloads({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetAllWorkloadsQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetAllWorkloads>>>
export type JiraGetAllWorkloadsQueryError = unknown


export function useJiraGetAllWorkloads<TData = Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetAllWorkloads>>,
          TError,
          Awaited<ReturnType<typeof jiraGetAllWorkloads>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetAllWorkloads<TData = Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetAllWorkloads>>,
          TError,
          Awaited<ReturnType<typeof jiraGetAllWorkloads>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetAllWorkloads<TData = Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get All Workloads
 */

export function useJiraGetAllWorkloads<TData = Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetAllWorkloads>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetAllWorkloadsQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Search for similar Jira issues using semantic similarity.
Useful for finding related issues or suggesting issue assignments.
Useful for finding related issues or suggesting issue assignments.
 * @summary Search Similar Issues
 */
export type jiraSearchSimilarIssuesResponse200 = {
  data: JiraSearchSimilarIssues200Item[]
  status: 200
}

export type jiraSearchSimilarIssuesResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraSearchSimilarIssuesResponseSuccess = (jiraSearchSimilarIssuesResponse200) & {
  headers: Headers;
};
export type jiraSearchSimilarIssuesResponseError = (jiraSearchSimilarIssuesResponse422) & {
  headers: Headers;
};

export type jiraSearchSimilarIssuesResponse = (jiraSearchSimilarIssuesResponseSuccess | jiraSearchSimilarIssuesResponseError)

export const getJiraSearchSimilarIssuesUrl = (params: JiraSearchSimilarIssuesParams,) => {
  const normalizedParams = new URLSearchParams();

  Object.entries(params || {}).forEach(([key, value]) => {
    
    if (value !== undefined) {
      normalizedParams.append(key, value === null ? 'null' : value.toString())
    }
  });

  const stringifiedParams = normalizedParams.toString();

  return stringifiedParams.length > 0 ? `http://127.0.0.1:8000/api/v1/jira/search/similar?${stringifiedParams}` : `http://127.0.0.1:8000/api/v1/jira/search/similar`
}

export const jiraSearchSimilarIssues = async (params: JiraSearchSimilarIssuesParams, options?: RequestInit): Promise<jiraSearchSimilarIssuesResponse> => {
  
  const res = await fetch(getJiraSearchSimilarIssuesUrl(params),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraSearchSimilarIssuesResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraSearchSimilarIssuesResponse
}




export const getJiraSearchSimilarIssuesMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraSearchSimilarIssues>>, TError,{params: JiraSearchSimilarIssuesParams}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof jiraSearchSimilarIssues>>, TError,{params: JiraSearchSimilarIssuesParams}, TContext> => {

const mutationKey = ['jiraSearchSimilarIssues'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jiraSearchSimilarIssues>>, {params: JiraSearchSimilarIssuesParams}> = (props) => {
          const {params} = props ?? {};

          return  jiraSearchSimilarIssues(params,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type JiraSearchSimilarIssuesMutationResult = NonNullable<Awaited<ReturnType<typeof jiraSearchSimilarIssues>>>
    
    export type JiraSearchSimilarIssuesMutationError = HTTPValidationError

    /**
 * @summary Search Similar Issues
 */
export const useJiraSearchSimilarIssues = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraSearchSimilarIssues>>, TError,{params: JiraSearchSimilarIssuesParams}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof jiraSearchSimilarIssues>>,
        TError,
        {params: JiraSearchSimilarIssuesParams},
        TContext
      > => {
      return useMutation(getJiraSearchSimilarIssuesMutationOptions(options), queryClient);
    }
    /**
 * Get full issue context including NLP-ready context string.
Useful for the recommendation engine.
 * @summary Get Issue Context
 */
export type jiraGetIssueContextResponse200 = {
  data: JiraIssueContent
  status: 200
}

export type jiraGetIssueContextResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type jiraGetIssueContextResponseSuccess = (jiraGetIssueContextResponse200) & {
  headers: Headers;
};
export type jiraGetIssueContextResponseError = (jiraGetIssueContextResponse422) & {
  headers: Headers;
};

export type jiraGetIssueContextResponse = (jiraGetIssueContextResponseSuccess | jiraGetIssueContextResponseError)

export const getJiraGetIssueContextUrl = (issueKey: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/jira/issues/${issueKey}/context`
}

export const jiraGetIssueContext = async (issueKey: string, options?: RequestInit): Promise<jiraGetIssueContextResponse> => {
  
  const res = await fetch(getJiraGetIssueContextUrl(issueKey),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraGetIssueContextResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraGetIssueContextResponse
}





export const getJiraGetIssueContextQueryKey = (issueKey: string,) => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/issues/${issueKey}/context`
    ] as const;
    }

    
export const getJiraGetIssueContextQueryOptions = <TData = Awaited<ReturnType<typeof jiraGetIssueContext>>, TError = HTTPValidationError>(issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraGetIssueContextQueryKey(issueKey);

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraGetIssueContext>>> = ({ signal }) => jiraGetIssueContext(issueKey, { signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, enabled: !!(issueKey), ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraGetIssueContextQueryResult = NonNullable<Awaited<ReturnType<typeof jiraGetIssueContext>>>
export type JiraGetIssueContextQueryError = HTTPValidationError


export function useJiraGetIssueContext<TData = Awaited<ReturnType<typeof jiraGetIssueContext>>, TError = HTTPValidationError>(
 issueKey: string, options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueContext>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueContext>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueContext<TData = Awaited<ReturnType<typeof jiraGetIssueContext>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraGetIssueContext>>,
          TError,
          Awaited<ReturnType<typeof jiraGetIssueContext>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraGetIssueContext<TData = Awaited<ReturnType<typeof jiraGetIssueContext>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Get Issue Context
 */

export function useJiraGetIssueContext<TData = Awaited<ReturnType<typeof jiraGetIssueContext>>, TError = HTTPValidationError>(
 issueKey: string, options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraGetIssueContext>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraGetIssueContextQueryOptions(issueKey,options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




/**
 * Webhook endpoint for receiving real-time updates from Jira.
Satisfies the optional real-time sync requirement.

Jira webhook events:
- jira:issue_created
- jira:issue_updated
- jira:issue_deleted
- comment_created
- comment_updated
- comment_deleted
- sprint_created
- sprint_updated
- sprint_closed
- sprint_deleted
- sprint_started

To configure this webhook in Jira:
1. Go to Jira Settings > System > Webhooks
2. Create a new webhook with URL: https://your-domain.com/api/v1/jira/webhook
3. Select the events you want to receive
4. Optionally add a secret to the URL for verification
 * @summary Jira Webhook
 */
export type jiraJiraWebhookResponse200 = {
  data: JiraJiraWebhook200
  status: 200
}
    
export type jiraJiraWebhookResponseSuccess = (jiraJiraWebhookResponse200) & {
  headers: Headers;
};
;

export type jiraJiraWebhookResponse = (jiraJiraWebhookResponseSuccess)

export const getJiraJiraWebhookUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/webhook`
}

export const jiraJiraWebhook = async ( options?: RequestInit): Promise<jiraJiraWebhookResponse> => {
  
  const res = await fetch(getJiraJiraWebhookUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraJiraWebhookResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraJiraWebhookResponse
}




export const getJiraJiraWebhookMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraJiraWebhook>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof jiraJiraWebhook>>, TError,void, TContext> => {

const mutationKey = ['jiraJiraWebhook'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof jiraJiraWebhook>>, void> = () => {
          

          return  jiraJiraWebhook(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type JiraJiraWebhookMutationResult = NonNullable<Awaited<ReturnType<typeof jiraJiraWebhook>>>
    
    export type JiraJiraWebhookMutationError = unknown

    /**
 * @summary Jira Webhook
 */
export const useJiraJiraWebhook = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof jiraJiraWebhook>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof jiraJiraWebhook>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getJiraJiraWebhookMutationOptions(options), queryClient);
    }
    /**
 * Test endpoint to verify webhook URL is accessible.
Jira may call this with GET to verify the URL.
 * @summary Test Webhook Endpoint
 */
export type jiraTestWebhookEndpointResponse200 = {
  data: JiraTestWebhookEndpoint200
  status: 200
}
    
export type jiraTestWebhookEndpointResponseSuccess = (jiraTestWebhookEndpointResponse200) & {
  headers: Headers;
};
;

export type jiraTestWebhookEndpointResponse = (jiraTestWebhookEndpointResponseSuccess)

export const getJiraTestWebhookEndpointUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/jira/webhook/test`
}

export const jiraTestWebhookEndpoint = async ( options?: RequestInit): Promise<jiraTestWebhookEndpointResponse> => {
  
  const res = await fetch(getJiraTestWebhookEndpointUrl(),
  {      
    ...options,
    method: 'GET'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: jiraTestWebhookEndpointResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as jiraTestWebhookEndpointResponse
}





export const getJiraTestWebhookEndpointQueryKey = () => {
    return [
    `http://127.0.0.1:8000/api/v1/jira/webhook/test`
    ] as const;
    }

    
export const getJiraTestWebhookEndpointQueryOptions = <TData = Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError = unknown>( options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData>>, fetch?: RequestInit}
) => {

const {query: queryOptions, fetch: fetchOptions} = options ?? {};

  const queryKey =  queryOptions?.queryKey ?? getJiraTestWebhookEndpointQueryKey();

  

    const queryFn: QueryFunction<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>> = ({ signal }) => jiraTestWebhookEndpoint({ signal, ...fetchOptions });

      

      

   return  { queryKey, queryFn, ...queryOptions} as UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData> & { queryKey: DataTag<QueryKey, TData, TError> }
}

export type JiraTestWebhookEndpointQueryResult = NonNullable<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>>
export type JiraTestWebhookEndpointQueryError = unknown


export function useJiraTestWebhookEndpoint<TData = Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError = unknown>(
  options: { query:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData>> & Pick<
        DefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>,
          TError,
          Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  DefinedUseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraTestWebhookEndpoint<TData = Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData>> & Pick<
        UndefinedInitialDataOptions<
          Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>,
          TError,
          Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>
        > , 'initialData'
      >, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
export function useJiraTestWebhookEndpoint<TData = Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient
  ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> }
/**
 * @summary Test Webhook Endpoint
 */

export function useJiraTestWebhookEndpoint<TData = Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError = unknown>(
  options?: { query?:Partial<UseQueryOptions<Awaited<ReturnType<typeof jiraTestWebhookEndpoint>>, TError, TData>>, fetch?: RequestInit}
 , queryClient?: QueryClient 
 ):  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> } {

  const queryOptions = getJiraTestWebhookEndpointQueryOptions(options)

  const query = useQuery(queryOptions, queryClient) as  UseQueryResult<TData, TError> & { queryKey: DataTag<QueryKey, TData, TError> };

  return { ...query, queryKey: queryOptions.queryKey };
}




