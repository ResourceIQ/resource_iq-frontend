/**
 * Generated by orval v8.0.3 ðŸº
 * Do not edit manually.
 * FastAPI Backend Project
 * OpenAPI spec version: 0.1.0
 */
import {
  useMutation
} from '@tanstack/react-query';
import type {
  MutationFunction,
  QueryClient,
  UseMutationOptions,
  UseMutationResult
} from '@tanstack/react-query';

import type {
  BodyLoginLoginAccessToken,
  HTTPValidationError,
  Message,
  NewPassword,
  Token,
  UserPublic
} from '../../model';





/**
 * OAuth2 compatible token login, get an access token for future requests
 * @summary Login Access Token
 */
export type loginLoginAccessTokenResponse200 = {
  data: Token
  status: 200
}

export type loginLoginAccessTokenResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type loginLoginAccessTokenResponseSuccess = (loginLoginAccessTokenResponse200) & {
  headers: Headers;
};
export type loginLoginAccessTokenResponseError = (loginLoginAccessTokenResponse422) & {
  headers: Headers;
};

export type loginLoginAccessTokenResponse = (loginLoginAccessTokenResponseSuccess | loginLoginAccessTokenResponseError)

export const getLoginLoginAccessTokenUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/login/access-token`
}

export const loginLoginAccessToken = async (bodyLoginLoginAccessToken: BodyLoginLoginAccessToken, options?: RequestInit): Promise<loginLoginAccessTokenResponse> => {
    const formUrlEncoded = new URLSearchParams();
if(bodyLoginLoginAccessToken.grant_type !== undefined && bodyLoginLoginAccessToken.grant_type !== null) {
 formUrlEncoded.append(`grant_type`, bodyLoginLoginAccessToken.grant_type);
 }
formUrlEncoded.append(`username`, bodyLoginLoginAccessToken.username);
formUrlEncoded.append(`password`, bodyLoginLoginAccessToken.password);
if(bodyLoginLoginAccessToken.scope !== undefined) {
 formUrlEncoded.append(`scope`, bodyLoginLoginAccessToken.scope);
 }
if(bodyLoginLoginAccessToken.client_id !== undefined && bodyLoginLoginAccessToken.client_id !== null) {
 formUrlEncoded.append(`client_id`, bodyLoginLoginAccessToken.client_id);
 }
if(bodyLoginLoginAccessToken.client_secret !== undefined && bodyLoginLoginAccessToken.client_secret !== null) {
 formUrlEncoded.append(`client_secret`, bodyLoginLoginAccessToken.client_secret);
 }

  const res = await fetch(getLoginLoginAccessTokenUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/x-www-form-urlencoded', ...options?.headers },
    body: 
      formUrlEncoded,
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginLoginAccessTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginLoginAccessTokenResponse
}




export const getLoginLoginAccessTokenMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLoginAccessToken>>, TError,{data: BodyLoginLoginAccessToken}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginLoginAccessToken>>, TError,{data: BodyLoginLoginAccessToken}, TContext> => {

const mutationKey = ['loginLoginAccessToken'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginLoginAccessToken>>, {data: BodyLoginLoginAccessToken}> = (props) => {
          const {data} = props ?? {};

          return  loginLoginAccessToken(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginLoginAccessTokenMutationResult = NonNullable<Awaited<ReturnType<typeof loginLoginAccessToken>>>
    export type LoginLoginAccessTokenMutationBody = BodyLoginLoginAccessToken
    export type LoginLoginAccessTokenMutationError = HTTPValidationError

    /**
 * @summary Login Access Token
 */
export const useLoginLoginAccessToken = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginLoginAccessToken>>, TError,{data: BodyLoginLoginAccessToken}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginLoginAccessToken>>,
        TError,
        {data: BodyLoginLoginAccessToken},
        TContext
      > => {
      return useMutation(getLoginLoginAccessTokenMutationOptions(options), queryClient);
    }
    /**
 * Test access token
 * @summary Test Token
 */
export type loginTestTokenResponse200 = {
  data: UserPublic
  status: 200
}
    
export type loginTestTokenResponseSuccess = (loginTestTokenResponse200) & {
  headers: Headers;
};
;

export type loginTestTokenResponse = (loginTestTokenResponseSuccess)

export const getLoginTestTokenUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/login/test-token`
}

export const loginTestToken = async ( options?: RequestInit): Promise<loginTestTokenResponse> => {
  
  const res = await fetch(getLoginTestTokenUrl(),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginTestTokenResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginTestTokenResponse
}




export const getLoginTestTokenMutationOptions = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginTestToken>>, TError,void, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginTestToken>>, TError,void, TContext> => {

const mutationKey = ['loginTestToken'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginTestToken>>, void> = () => {
          

          return  loginTestToken(fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginTestTokenMutationResult = NonNullable<Awaited<ReturnType<typeof loginTestToken>>>
    
    export type LoginTestTokenMutationError = unknown

    /**
 * @summary Test Token
 */
export const useLoginTestToken = <TError = unknown,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginTestToken>>, TError,void, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginTestToken>>,
        TError,
        void,
        TContext
      > => {
      return useMutation(getLoginTestTokenMutationOptions(options), queryClient);
    }
    /**
 * Password Recovery
 * @summary Recover Password
 */
export type loginRecoverPasswordResponse200 = {
  data: Message
  status: 200
}

export type loginRecoverPasswordResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type loginRecoverPasswordResponseSuccess = (loginRecoverPasswordResponse200) & {
  headers: Headers;
};
export type loginRecoverPasswordResponseError = (loginRecoverPasswordResponse422) & {
  headers: Headers;
};

export type loginRecoverPasswordResponse = (loginRecoverPasswordResponseSuccess | loginRecoverPasswordResponseError)

export const getLoginRecoverPasswordUrl = (email: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/password-recovery/${email}`
}

export const loginRecoverPassword = async (email: string, options?: RequestInit): Promise<loginRecoverPasswordResponse> => {
  
  const res = await fetch(getLoginRecoverPasswordUrl(email),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginRecoverPasswordResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginRecoverPasswordResponse
}




export const getLoginRecoverPasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPassword>>, TError,{email: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPassword>>, TError,{email: string}, TContext> => {

const mutationKey = ['loginRecoverPassword'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginRecoverPassword>>, {email: string}> = (props) => {
          const {email} = props ?? {};

          return  loginRecoverPassword(email,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginRecoverPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof loginRecoverPassword>>>
    
    export type LoginRecoverPasswordMutationError = HTTPValidationError

    /**
 * @summary Recover Password
 */
export const useLoginRecoverPassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPassword>>, TError,{email: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginRecoverPassword>>,
        TError,
        {email: string},
        TContext
      > => {
      return useMutation(getLoginRecoverPasswordMutationOptions(options), queryClient);
    }
    /**
 * Reset password
 * @summary Reset Password
 */
export type loginResetPasswordResponse200 = {
  data: Message
  status: 200
}

export type loginResetPasswordResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type loginResetPasswordResponseSuccess = (loginResetPasswordResponse200) & {
  headers: Headers;
};
export type loginResetPasswordResponseError = (loginResetPasswordResponse422) & {
  headers: Headers;
};

export type loginResetPasswordResponse = (loginResetPasswordResponseSuccess | loginResetPasswordResponseError)

export const getLoginResetPasswordUrl = () => {


  

  return `http://127.0.0.1:8000/api/v1/reset-password/`
}

export const loginResetPassword = async (newPassword: NewPassword, options?: RequestInit): Promise<loginResetPasswordResponse> => {
  
  const res = await fetch(getLoginResetPasswordUrl(),
  {      
    ...options,
    method: 'POST',
    headers: { 'Content-Type': 'application/json', ...options?.headers },
    body: JSON.stringify(
      newPassword,)
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginResetPasswordResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginResetPasswordResponse
}




export const getLoginResetPasswordMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginResetPassword>>, TError,{data: NewPassword}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginResetPassword>>, TError,{data: NewPassword}, TContext> => {

const mutationKey = ['loginResetPassword'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginResetPassword>>, {data: NewPassword}> = (props) => {
          const {data} = props ?? {};

          return  loginResetPassword(data,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginResetPasswordMutationResult = NonNullable<Awaited<ReturnType<typeof loginResetPassword>>>
    export type LoginResetPasswordMutationBody = NewPassword
    export type LoginResetPasswordMutationError = HTTPValidationError

    /**
 * @summary Reset Password
 */
export const useLoginResetPassword = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginResetPassword>>, TError,{data: NewPassword}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginResetPassword>>,
        TError,
        {data: NewPassword},
        TContext
      > => {
      return useMutation(getLoginResetPasswordMutationOptions(options), queryClient);
    }
    /**
 * HTML Content for Password Recovery (Admin only)
 * @summary Recover Password Html Content
 */
export type loginRecoverPasswordHtmlContentResponse200 = {
  data: string
  status: 200
}

export type loginRecoverPasswordHtmlContentResponse422 = {
  data: HTTPValidationError
  status: 422
}
    
export type loginRecoverPasswordHtmlContentResponseSuccess = (loginRecoverPasswordHtmlContentResponse200) & {
  headers: Headers;
};
export type loginRecoverPasswordHtmlContentResponseError = (loginRecoverPasswordHtmlContentResponse422) & {
  headers: Headers;
};

export type loginRecoverPasswordHtmlContentResponse = (loginRecoverPasswordHtmlContentResponseSuccess | loginRecoverPasswordHtmlContentResponseError)

export const getLoginRecoverPasswordHtmlContentUrl = (email: string,) => {


  

  return `http://127.0.0.1:8000/api/v1/password-recovery-html-content/${email}`
}

export const loginRecoverPasswordHtmlContent = async (email: string, options?: RequestInit): Promise<loginRecoverPasswordHtmlContentResponse> => {
  
  const res = await fetch(getLoginRecoverPasswordHtmlContentUrl(email),
  {      
    ...options,
    method: 'POST'
    
    
  }
)

  const body = [204, 205, 304].includes(res.status) ? null : await res.text();
  
  const data: loginRecoverPasswordHtmlContentResponse['data'] = body ? JSON.parse(body) : {}
  return { data, status: res.status, headers: res.headers } as loginRecoverPasswordHtmlContentResponse
}




export const getLoginRecoverPasswordHtmlContentMutationOptions = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>, TError,{email: string}, TContext>, fetch?: RequestInit}
): UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>, TError,{email: string}, TContext> => {

const mutationKey = ['loginRecoverPasswordHtmlContent'];
const {mutation: mutationOptions, fetch: fetchOptions} = options ?
      options.mutation && 'mutationKey' in options.mutation && options.mutation.mutationKey ?
      options
      : {...options, mutation: {...options.mutation, mutationKey}}
      : {mutation: { mutationKey, }, fetch: undefined};

      


      const mutationFn: MutationFunction<Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>, {email: string}> = (props) => {
          const {email} = props ?? {};

          return  loginRecoverPasswordHtmlContent(email,fetchOptions)
        }



        


  return  { mutationFn, ...mutationOptions }}

    export type LoginRecoverPasswordHtmlContentMutationResult = NonNullable<Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>>
    
    export type LoginRecoverPasswordHtmlContentMutationError = HTTPValidationError

    /**
 * @summary Recover Password Html Content
 */
export const useLoginRecoverPasswordHtmlContent = <TError = HTTPValidationError,
    TContext = unknown>(options?: { mutation?:UseMutationOptions<Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>, TError,{email: string}, TContext>, fetch?: RequestInit}
 , queryClient?: QueryClient): UseMutationResult<
        Awaited<ReturnType<typeof loginRecoverPasswordHtmlContent>>,
        TError,
        {email: string},
        TContext
      > => {
      return useMutation(getLoginRecoverPasswordHtmlContentMutationOptions(options), queryClient);
    }
    